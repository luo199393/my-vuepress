(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{542:function(t,s,n){"use strict";n.r(s);var e=n(10),a=Object(e.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"react基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react基础"}},[t._v("#")]),t._v(" react基础")]),t._v(" "),n("blockquote",[n("p",[t._v("生命周期")])]),t._v(" "),n("ul",[n("li",[t._v("getDefaultProps:获取实例的默认属性")]),t._v(" "),n("li",[t._v("getInitialState:获取每个实例的初始化状态")]),t._v(" "),n("li",[t._v("componentWillMount：组件即将被装载、渲染到页面上")]),t._v(" "),n("li",[t._v("render:组件在这里生成虚拟的 DOM 节点")]),t._v(" "),n("li",[t._v("componentDidMount:组件真正在被装载之后(http请求应该在此阶段)")]),t._v(" "),n("li",[t._v("componentWillReceiveProps:组件将要接收到属性的时候调用")]),t._v(" "),n("li",[t._v("shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）")]),t._v(" "),n("li",[t._v("componentWillUpdate:组件即将更新不能修改属性和状态")]),t._v(" "),n("li",[t._v("render:组件重新描绘")]),t._v(" "),n("li",[t._v("componentDidUpdate:组件已经更新")]),t._v(" "),n("li",[t._v("componentWillUnmount:组件即将销毁")])]),t._v(" "),n("blockquote",[n("p",[t._v("this.setState()")])]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setState是一个异步函数")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("data\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...数据更新后回调执行")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br")])]),n("blockquote",[n("p",[t._v("react diff 原理")])]),t._v(" "),n("ul",[n("li",[t._v("把树形结构按照层级分解，只比较同级元素。")]),t._v(" "),n("li",[t._v("给列表结构的每个单元添加唯一的 key 属性，方便比较。")]),t._v(" "),n("li",[t._v("React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）")]),t._v(" "),n("li",[t._v("合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.")]),t._v(" "),n("li",[t._v("选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。")])]),t._v(" "),n("blockquote",[n("p",[t._v("super(props)")])]),t._v(" "),n("ul",[n("li",[t._v("在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);